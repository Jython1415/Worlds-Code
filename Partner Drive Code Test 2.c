#pragma config(Sensor, in8,    armPot,         sensorPotentiometer)
#pragma config(Motor,  port2,           mogoLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           leftFront,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           leftBack,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           rightBack,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           arm,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           claw,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           mogoRight,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           rightFront,    tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define driveNormalSpeed             0.6 //default for Joseph Bot is 0.6
#define driveFastSpeed                 1 //default for Joseph Bot is   1
#define driveSlowSpeed               0.3 //default for Joseph Bot is 0.3

#define joystickThreshold      20
#define armLowerLimit        3250
#define armRaiseLimit        1520

int left_y;
int right_y;
int left_TU;
int left_TD;
float driveMode;

int leftPwr;
int rightPwr;
int armPwr;
int mogoPwr;
int clawPwr;
bool clawOpen = true;
bool clawMoving = false;
int clawTimer = 0;
int debugOutputTimer = 0;

task main() {
	while (true) {
		if (debugOutputTimer == 8) {
			debugOutputTimer = 0;

			writeDebugStreamLine("armPot: %d", SensorValue[armPot]);

			/*
			if (vexRT[Btn5UXmtr2] == 1 && vexRT[Btn5DXmtr2] == 0) {
				writeDebugStreamLine("arm up");
			}
			if (vexRT[Btn5UXmtr2] == 0 && vexRT[Btn5DXmtr2] == 1) {
				writeDebugStreamLine("arm down");
			}
			//*/

			/*
			writeDebugStreamLine("Btn5UXmtr2: %d", vexRT[Btn5UXmtr2]);
			writeDebugStreamLine("Btn5DXmtr2: %d", vexRT[Btn5DXmtr2]);
			//*/

			//test = vexRT[Btn5UXmtr2];

			//writeDebugStreamLine("armPwr: %d", armPwr);
		}

		left_y = vexRT[Ch3];
		right_y = vexRT[Ch2];
		left_TU = vexRT[Btn5U];
		left_TD = vexRT[Btn5D];

		//leftPwr = (abs(vexRT[Ch3]) < joystickThreshold) ? 0 : vexRT[Ch3];
		//rightPwr = (abs(vexRT[Ch2]) < joystickThreshold) ? 0 : vexRT[Ch2];
		driveMode = (left_TU == 1) ? (left_TD == 1) ? driveNormalSpeed : driveFastSpeed : (left_TD == 1) ? driveSlowSpeed : driveNormalSpeed;
		leftPwr = (abs(left_y) > joystickThreshold) ? left_y*driveMode : 0;
		rightPwr = (abs(right_y) > joystickThreshold) ? right_y*driveMode : 0;

		armPwr = (vexRT[Btn5UXmtr2] == 1 && vexRT[Btn5DXmtr2] == 0) ? 90 : (vexRT[Btn5UXmtr2] == 0 && vexRT[Btn5DXmtr2] == 1) ? -90 : 0;
		armPwr = (armPwr == 0 && SensorValue[armPot] > armLowerLimit) ? -15 : armPwr; // this is the power for holding
																																									// the arm down when you want to
																																									// grab a cone normally
		armPwr = (armPwr == 0 && SensorValue[armPot] < armRaiseLimit) ? 20 : armPwr;  // this is the power for holding
																																									// the arm up when you want to stack

		mogoPwr = (vexRT[Btn6U] == 1 && vexRT[Btn6D] == 0) ? 90 : (vexRT[Btn6U] == 0 && vexRT[Btn6D] == 1) ? -90 : 0;

		if (vexRT[Btn8LXmtr2] == 1 && vexRT[Btn8DXmtr2] == 0) {
			clawOpen = true;
			clawTimer = 0;
		}
		else if (vexRT[Btn8LXmtr2] == 0 && vexRT[Btn8DXmtr2] == 1) {
			clawOpen = false;
			clawTimer = 0;
		}

		clawMoving = (clawTimer < 30) ? true : false;
		clawPwr = (clawOpen) ? 60 : -60;
		clawPwr = (clawMoving) ? clawPwr : (clawPwr < 0) ? -25 : 8;

		motor[leftFront] = leftPwr;
		motor[leftBack] = leftPwr;
		motor[rightFront] = rightPwr;
		motor[rightBack] = rightPwr;
		motor[arm] = armPwr;
		motor[mogoLeft] = mogoPwr;
		motor[mogoRight] = mogoPwr;
		motor[claw] = clawPwr;

		clawTimer += 1;
		debugOutputTimer += 1;

		wait1Msec(25);
	}
}
